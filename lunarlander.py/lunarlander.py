# AUTOGENERATED! DO NOT EDIT! File to edit: ../lunarlander.ipynb.

# %% auto 0
__all__ = ['MEMORY_SIZE', 'GAMMA', 'LEARNING_RATE', 'NUM_STEPS_FOR_UPDATE', 'SEED', 'MINIBATCH_SIZE', 'TAU', 'E_DECAY', 'E_MIN',
           'experience', 'env', 'state_size', 'num_actions', 'q_network', 'target_q_network', 'optimizer', 'start',
           'num_episodes', 'max_num_timesteps', 'total_point_history', 'num_p_av', 'epsilon', 'memory_buffer',
           'tot_time', 'compute_loss', 'agent_learn', 'get_experiences', 'check_update_conditions', 'get_new_eps',
           'get_action', 'plot_history']

# %% ../lunarlander.ipynb 1
# Import the relevant libraries
import os
import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
import gym
import time
import random
import pandas as pd
from collections import deque, namedtuple
from pyvirtualdisplay import Display
from tensorflow.keras import Sequential
from tensorflow.keras.layers import Dense, Input
from tensorflow.keras.losses import MSE
from tensorflow.keras.optimizers import Adam
from PIL import Image
import PIL

# %% ../lunarlander.ipynb 2
# Initialize all the parameters
MEMORY_SIZE = 100000    
GAMMA = 0.995            
LEARNING_RATE = 1e-3               
NUM_STEPS_FOR_UPDATE = 4 
SEED = 0              
MINIBATCH_SIZE = 64   
TAU = 1e-3           
E_DECAY = 0.995      
E_MIN = 0.01       

# Using Namedtuple to store the experience
experience = namedtuple("Experience", field_names=["state", "action", "reward", "next_state", "done"])

# Set the seed
random.seed(SEED)

# %% ../lunarlander.ipynb 3
# Initialize the gym environment
env = gym.make('LunarLander-v2')
env = gym.make("LunarLander-v2", render_mode="human")
state_size = env.observation_space.shape
num_actions = env.action_space.n

# %% ../lunarlander.ipynb 4
# Define the models and optimizer
q_network = Sequential([
    Input(shape=state_size),
    Dense(64,activation='relu'),
    Dense(64,activation='relu'),
    Dense(num_actions,activation='linear')
]) 

target_q_network = Sequential([
    Input(shape=state_size),
    Dense(64,activation='relu'),
    Dense(64,activation='relu'),
    Dense(num_actions,activation='linear')
]) 

optimizer = Adam(learning_rate=LEARNING_RATE)

# %% ../lunarlander.ipynb 5
# Define the loss function
def compute_loss(experiences, gamma, q_network, target_q_network):
    
    states, actions,rewards,next_states,done_vals = experiences
    max_qsa = tf.reduce_max(target_q_network(next_states), axis=-1)
    y_targets = rewards + (gamma * max_qsa * (1 - done_vals))
    q_values = q_network(states)
    q_values = tf.gather_nd(q_values, tf.stack([tf.range(q_values.shape[0]),
                                                tf.cast(actions, tf.int32)], axis=1))
    loss = MSE(y_targets, q_values)
    return loss

# %% ../lunarlander.ipynb 6
# Define the update step
@tf.function
def agent_learn(experiences, gamma):    
    # Calculate the loss
    with tf.GradientTape() as tape:
        loss = compute_loss(experiences, gamma, q_network, target_q_network)

    # Get the gradients of the loss with respect to the weights.
    gradients = tape.gradient(loss, q_network.trainable_variables)
    
    # Update the weights of the q_network.
    optimizer.apply_gradients(zip(gradients, q_network.trainable_variables))

    # update the weights of target q_network
    for target_weights, q_net_weights in zip(target_q_network.weights, q_network.weights):
        target_weights.assign(TAU * q_net_weights + (1.0 - TAU) * target_weights)

# %% ../lunarlander.ipynb 7
# Function to retrieve the experiences
def get_experiences(memory_buffer):
    experiences = random.sample(memory_buffer, k=MINIBATCH_SIZE)
    states = tf.convert_to_tensor(np.array([e.state for e in experiences if e is not None]),dtype=tf.float32)
    actions = tf.convert_to_tensor(np.array([e.action for e in experiences if e is not None]), dtype=tf.float32)
    rewards = tf.convert_to_tensor(np.array([e.reward for e in experiences if e is not None]), dtype=tf.float32)
    next_states = tf.convert_to_tensor(np.array([e.next_state for e in experiences if e is not None]),dtype=tf.float32)
    done_vals = tf.convert_to_tensor(np.array([e.done for e in experiences if e is not None]).astype(np.uint8),
                                     dtype=tf.float32)
    return (states, actions, rewards, next_states, done_vals)

# %% ../lunarlander.ipynb 8
# Funtion to check for the update condition
def check_update_conditions(t, num_steps_upd, memory_buffer):
    if (t + 1) % num_steps_upd == 0 and len(memory_buffer) > MINIBATCH_SIZE:
        return True
    else:
        return False

# %% ../lunarlander.ipynb 9
# Function to update and get the new epsilon
def get_new_eps(epsilon):
    return max(E_MIN, E_DECAY*epsilon)

# %% ../lunarlander.ipynb 10
# Function to get the next action
def get_action(q_values, epsilon=0):
    if random.random() > epsilon:
        return np.argmax(q_values.numpy()[0])
    else:
        return random.choice(np.arange(4))
